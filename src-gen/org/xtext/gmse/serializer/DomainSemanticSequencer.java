/*
 * generated by Xtext 2.18.0
 */
package org.xtext.gmse.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.gmse.domain.Artist;
import org.xtext.gmse.domain.DomainPackage;
import org.xtext.gmse.domain.Festival;
import org.xtext.gmse.domain.Food;
import org.xtext.gmse.domain.FoodLineup;
import org.xtext.gmse.domain.Lineup;
import org.xtext.gmse.domain.Stage;
import org.xtext.gmse.domain.Stagelist;
import org.xtext.gmse.domain.Timetable;
import org.xtext.gmse.domain.TimetableEntry;
import org.xtext.gmse.services.DomainGrammarAccess;

@SuppressWarnings("all")
public class DomainSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DomainGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DomainPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DomainPackage.ARTIST:
				sequence_Artist(context, (Artist) semanticObject); 
				return; 
			case DomainPackage.FESTIVAL:
				sequence_Festival(context, (Festival) semanticObject); 
				return; 
			case DomainPackage.FOOD:
				sequence_Food(context, (Food) semanticObject); 
				return; 
			case DomainPackage.FOOD_LINEUP:
				sequence_FoodLineup(context, (FoodLineup) semanticObject); 
				return; 
			case DomainPackage.LINEUP:
				sequence_Lineup(context, (Lineup) semanticObject); 
				return; 
			case DomainPackage.STAGE:
				sequence_Stage(context, (Stage) semanticObject); 
				return; 
			case DomainPackage.STAGELIST:
				sequence_Stagelist(context, (Stagelist) semanticObject); 
				return; 
			case DomainPackage.TIMETABLE:
				sequence_Timetable(context, (Timetable) semanticObject); 
				return; 
			case DomainPackage.TIMETABLE_ENTRY:
				sequence_TimetableEntry(context, (TimetableEntry) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Artist returns Artist
	 *
	 * Constraint:
	 *     (name=STRING country=STRING)
	 */
	protected void sequence_Artist(ISerializationContext context, Artist semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.ARTIST__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.ARTIST__NAME));
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.ARTIST__COUNTRY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.ARTIST__COUNTRY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArtistAccess().getNameSTRINGTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getArtistAccess().getCountrySTRINGTerminalRuleCall_2_0(), semanticObject.getCountry());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Festival returns Festival
	 *
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         visitors=INT 
	 *         startdate=STRING 
	 *         enddate=STRING 
	 *         lineup=Lineup 
	 *         stages=Stagelist 
	 *         timetable=Timetable 
	 *         foodLineup=FoodLineup?
	 *     )
	 */
	protected void sequence_Festival(ISerializationContext context, Festival semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FoodLineup returns FoodLineup
	 *
	 * Constraint:
	 *     foodlist+=Food+
	 */
	protected void sequence_FoodLineup(ISerializationContext context, FoodLineup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Food returns Food
	 *
	 * Constraint:
	 *     (name=STRING type=STRING place=STRING)
	 */
	protected void sequence_Food(ISerializationContext context, Food semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.FOOD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.FOOD__NAME));
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.FOOD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.FOOD__TYPE));
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.FOOD__PLACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.FOOD__PLACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFoodAccess().getNameSTRINGTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFoodAccess().getTypeSTRINGTerminalRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFoodAccess().getPlaceSTRINGTerminalRuleCall_4_0(), semanticObject.getPlace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Lineup returns Lineup
	 *
	 * Constraint:
	 *     artists+=Artist+
	 */
	protected void sequence_Lineup(ISerializationContext context, Lineup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stage returns Stage
	 *
	 * Constraint:
	 *     (name=STRING capacity=INT info=STRING)
	 */
	protected void sequence_Stage(ISerializationContext context, Stage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.STAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.STAGE__NAME));
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.STAGE__CAPACITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.STAGE__CAPACITY));
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.STAGE__INFO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.STAGE__INFO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStageAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStageAccess().getCapacityINTTerminalRuleCall_3_0(), semanticObject.getCapacity());
		feeder.accept(grammarAccess.getStageAccess().getInfoSTRINGTerminalRuleCall_5_0(), semanticObject.getInfo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stagelist returns Stagelist
	 *
	 * Constraint:
	 *     stages+=Stage+
	 */
	protected void sequence_Stagelist(ISerializationContext context, Stagelist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimetableEntry returns TimetableEntry
	 *
	 * Constraint:
	 *     (name=[Artist|STRING] day=days time=STRING stage=[Stage|STRING])
	 */
	protected void sequence_TimetableEntry(ISerializationContext context, TimetableEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.TIMETABLE_ENTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.TIMETABLE_ENTRY__NAME));
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.TIMETABLE_ENTRY__DAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.TIMETABLE_ENTRY__DAY));
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.TIMETABLE_ENTRY__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.TIMETABLE_ENTRY__TIME));
			if (transientValues.isValueTransient(semanticObject, DomainPackage.Literals.TIMETABLE_ENTRY__STAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainPackage.Literals.TIMETABLE_ENTRY__STAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimetableEntryAccess().getNameArtistSTRINGTerminalRuleCall_1_0_1(), semanticObject.eGet(DomainPackage.Literals.TIMETABLE_ENTRY__NAME, false));
		feeder.accept(grammarAccess.getTimetableEntryAccess().getDayDaysEnumRuleCall_3_0(), semanticObject.getDay());
		feeder.accept(grammarAccess.getTimetableEntryAccess().getTimeSTRINGTerminalRuleCall_5_0(), semanticObject.getTime());
		feeder.accept(grammarAccess.getTimetableEntryAccess().getStageStageSTRINGTerminalRuleCall_7_0_1(), semanticObject.eGet(DomainPackage.Literals.TIMETABLE_ENTRY__STAGE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Timetable returns Timetable
	 *
	 * Constraint:
	 *     timetable+=TimetableEntry+
	 */
	protected void sequence_Timetable(ISerializationContext context, Timetable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
